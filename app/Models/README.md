# Модели

Модели по своей сути являются связующим звеном между таблицей в БД и приложением.
При этом, в них можно вообще ничего не изменять после создания! Они и так изначально умеют почти всё.

## Поля

+ Поле ```incrementing``` было изменено на ```false```, т.к. в архитектуре используется ```uniqueId()``` в качестве первичного ключа, которое является строкой. При этом, если не отключить автоинкремент, то ```Eloquent```, попытается инкрементировать строку, и несмотря на неудачу, в конце всё равно сконвертирует его в ```int```.

+ В поле ```fillable``` вписываются название всех столбцов, которые должны изменяться в БД, последствием ```POST``` и ```PUT``` запросов

+ Поле casts отвечает за автоматические преобразования типов переменных. Во всех моделях было добавлено поле ```id```, т.к. по умолчанию Eloquent конвертирует это поле в ```int```, а для нормальной работы нужен ```string```

## Методы

+ В модель ```User``` был добавлен метод [мутатор](https://laravel.com/docs/9.x/eloquent-mutators) ```setPasswordAttribute```, который автоматически хеширует поле с входящими паролями

### [Связи](https://laravel.com/docs/9.x/eloquent-relationships#one-to-many)

В ```Eloquent``` все связи также задаются в методах моделей. Так, в родительской сущности задаётся метод с названием дочерней в единственном, или множественном числе, внутри которого возвращается вызов метода ```hasMany```, или ```hasOne``` у указателя ```$this```. Внутрь метода передаётся класс дочерней сущности, а также, опциональный параметр названия внешнего ключа, если он отличается от стандартов.
Далее, в дочерней сущности, также создаётся соответствующий метод для обратной связи. При этом, у указателя ```$this``` вызываются уже методы ```belongsTo```, или ```belongsToMany```, с аналогичными входными параметрами. В ```Eloquent``` доступны все виды связи: один к одному, один ко многим и многие ко многим, благодаря комбинированию различных видов вышеописанных методов. В проекте используются только отношения ```one to many```, так как отношение многие ко многим уже было раскрыто на этапе проектирования БД.
