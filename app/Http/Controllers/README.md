# Контроллеры

Контроллеры отвечают за корректную работу всех view приложения. 
В контроллерах указывается весь необходимый функционал, перед непосредственным отображением страницы

# Аутентификация

За работу аутентификации отвечают [RegistrationController](https://github.com/DavidaaWoW/GlobusDelievery/blob/master/app/Http/Controllers/RegistrationController.php) и [LoginController](https://github.com/DavidaaWoW/GlobusDelievery/blob/master/app/Http/Controllers/LoginController.php)

В контроллере регистрации присутствует единственный метод save, который в параметрах получает входящий запрос

*В laravel контроллерах любой метод, помимо явно передаваемых параметров, может получать также параметр типа ```Request```, в котором находится вся информация по входящему запросу*

Изначально, проверяется текущий статус аутентификации - если пользователь уже аутентифицирован, то ему не нужен доступ к страницам аутентификации.

Далее, происходит автоматическая [валидация](https://laravel.com/docs/9.x/validation#main-content) полей почты и пароля. Так, почта обязательна для заполнения, должна быть валидным электронным адресом, а также, должна быть уникальной в пределах БД пользователей. А пароль, просто является обязательным полем.

В случае, если валидация не проходит, выполнение метода прерывается, а запрос возвращается назад, с параметрами ошибок, которые далее могут быть обработаны в ```Blade``` шаблонах.

Следующим шагом добавляем к массиву поле ```id```, которое генерируем встроенной в PHP функцией.

После чего создаём пользователя, передавая в статический метод create массив параметров.

Если пользователь создался, то сразу же выполняем вход, а также передаём дефолтный набор параметров в БД редиса. После чего выполняем редирект в профиль пользователя.

Иначе опять переходим на текущую страницу, передавая ошибки.

В метод ```Auth::login()```, во входящие параметры передатся созданный объект пользователя, а также булевый каст поля запоминания данных для аутентификации, которое пользователь может либо выбрать, либо нет. Те же манипуляции происходят и во время логина.


В контроллере логина получаем лишь необходимые поля из запроса, методом ```only()```, после чего также выполняем попытку входа.

# Рестораны

В контроллере ресторанов присутствуют два метода.
Первый метод - ```showAll()``` по умолчанию выводит список всех возможных ресторанов, отображая view - ```user.restaurants```, отправляя внутрь в параметрах список ресторанов, которые отсортированы по имени в порядке возрастания.

Второй же метод - ```search()```, отвечает за процесс поиска и сортировки ресторанов в приложении. Он получает на вход параметр запроса, из которого вытаскиваются необходимые данные: параметры поиска, тип и вид сортировки.
Если пользователь не ввёл ничего в поле поиска, то просто отправляется список ресторанов отсортированный запрошенным способом.
Иначе, к запросу добавляется условие where, в котором по БД ищется любой ресторан, имя которого содержит запрос - ``` ... like %name% ... ```.

# Блюда и категории

В контроллере блюд и категорий присутствует единственный метод - ```showAll()```, отвечающий за отображение всех категорий и блюд выбранного ресторана. На вход получает само название ресторана в виде отдельного параметра, а также параметр запроса.
Далее, происходит последовательное заполнение массивов категорий и блюд. В результате отдаём view ```user.rest_content```, со списком всех найденных категорий и блюд ресторана, а также возвратом его названия.

# Заказы

Основным контроллером работы с корзиной и заказами является [OrdersController](https://github.com/DavidaaWoW/GlobusDelievery/blob/master/app/Http/Controllers/OrdersController.php) 

### addToCart

Начинается всё с метода ```addToCart``` отвечающего за первоначальное добавление товара в корзину, если там его нет. На вход в параметрах получаем параметр ```Request```. Изначально проверяется наличие текущего заказа у пользователя. В данной архитектуре параметр текущего заказа фактически является объектом корзины. При этом данная связь может либо существовать, либо не существовать на разных этапов жизненного цикла приложения. 
У конкретного пользователя поле ```currentOrder``` пусто в том случае когда:
+ У пользователя новый аккаунт, при работе с которым он ещё не добавлял блюда в корзину
+ Сразу же после оформления заказа корзина трансформируется в объект заказа, и соответственно данная связь обнуляется

При этом в данном методе, при условии отсутствия текущего заказа у пользователя создаётся новый объект заказа, к нему привязывается пользователь, поле суммы (```total_price```) задаётся нулём, а статусом становится ```in progress```. 

Если у пользователя уже есть текущий заказ, то его объект просто нужно получить.

Далее, создаётся новый объект ```orderItem``` - развёртка через промежуточную таблицу между заказами и блюдами, к объекту привязываются все эти связи. В результате работы данного метода, в качестве ответа отправляется json объект текущего заказа.

### increase / descrease

Далее, обработка блюда в пределах заказа происходит с помощью методов ```increase``` и ```decrease``` соответственно. Внутри которых происходит либо увеличение, либо уменьшение количество блюда на единицу в текущем заказе. При этом, если был вызван метод ```decrease``` и количество блюда равно единицы, то вместо его уменьшения, происходит удаление.

Результатом работы обоих методов является json ответ с текущим заказом.

### removeFromCart

Помимо последовательного уменьшения количества товара, удаление его из корзины может также происходить и в одно действие. При вызове данного метода от общей цены заказа отнимается стоимость количества данного товара умноженное на его цену. После чего товар можно удалять.

### placeOrder

Данный метод отвечает за оформление заказа.

*На текущем этапе разработки приложения оформление представляет собой изменение статуса заказа, с помещением в архив, а также удалением связи ```current_order``` у пользователя.*


