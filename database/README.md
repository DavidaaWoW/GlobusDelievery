# Базы данных и всё, что с ними едят

Подключение к базам данных задаётся в конфигурационном файле [database.php](https://github.com/DavidaaWoW/GlobusDelievery/blob/master/config/database.php), а также в файле ```.env```

В файле ```database.php``` задаётся БД по умолчанию (default), а также вводятся данные для подключения к каждой из необходимых БД, и отдельно для Redis

**Важно, что вместо ```localhost```, в качестве хоста нужно указывать название контейнера**

## [Миграции](https://laravel.com/docs/9.x/migrations)

В папке [migrations](https://github.com/DavidaaWoW/GlobusDelievery/tree/master/database/migrations) создаются миграции всех таблиц будущей базы данных. 

*Для работы миграций внутри docker container-ов необходимо установить в php расширение ```mysql-pdo```, а также включить внутреннее его использование в файле глобальной конфигурации ```php.ini```*

*Миграции выполняются в apache контейнере, из корневой директории проекта, командой* ```php artisan migrate```

В файлах миграций отражена внутренняя структура sql таблиц. Первые три файла были сгенерированы автоматически.

Поле ```remember_token``` отвечает за сохранение токена для запоминания пользователей. Весь процесс доступен "из коробки" и практически не требует участия разработчика.

Поле ```timestamps``` отвечает за создание двух полей: 

- дата создания записи
- дата обновления записи *значение будет автоматически будет обновляться при каждом обновлении любого поля*

Поле ```foreignId``` отвечает за установку внешнего ключа, методом ```constrained``` привязываем название таблицы

Помимо метода ```up()```, в котором определяется создание таблицы, в файле миграций также существует метод ```down()```, который срабатывает при выполнении команды ```php artisan migrate:rollback```, по сути откатывая миграции.

В качестве развёртки соединения ```many to many``` между заказами и блюдами, была создана промежуточная таблица ```order_items```. В экосистеме ```Eloquent``` такую таблицу можно было **НЕ** создавать вручную, пользуясь вместо неё встроенными отношениями ```many to many```. Однако, ещё на этапе концептуального проектирования БД было решено разложить данную связь и создать отдельную миграцию.

## Триггеры

Расчёт поля общей стоимости в заказе было решено переложить на сторону БД. Для этого в базе данных были созданы 3 триггера, использующиеся перед созданием, обновлением и удалением данных в таблице ```order_items```

Рассмотрим для примера триггер перед созданием:

```
delimiter |
create trigger `count_total_price` before insert on `order_items`
for each row begin
    declare _price float;
    select price into _price from meals where id=NEW.meal_id;
    update orders set total_price = total_price + _price where id=NEW.order_id;
end;|
delimiter ;
```

Триггер настроен ```before insert```, как ясно из названия, выполняется перед вставкой данных в таблицу ```order_items```. Объявляем переменную ```_price```, далее, помещаем в неё цену продукта, который находим по его уникальному идентификатору, являющимся также полем с внешним ключём в таблице ```order_items```.
И наконец обновляем таблицу заказов, а именно заказ, ```id``` которого также берём из внешнего ключа ```order_items```, внутри по сути прибавляем к текущем значению ```total_price``` значение цены полученное из таблицы блюд. В контексте связи с текущим интерфейсом, перед вставкой нет необходимости умножать на количество товара, потому-что добавляется ```order_items``` только по одной штуке.

 Код исходных триггеров и команд находится в файле инициализации [init.sql](https://github.com/DavidaaWoW/GlobusDelievery/blob/master/mysql/init.sql)
